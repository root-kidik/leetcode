___
## Task
Given an array of strings `words`, return _the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below_.

**Note** that the strings are **case-insensitive**, both lowercased and uppercased of the same letter are treated as if they are at the same row.

In the **American keyboard**:

- the first row consists of the characters `"qwertyuiop"`,
- the second row consists of the characters `"asdfghjkl"`, and
- the third row consists of the characters `"zxcvbnm"`.

![](https://assets.leetcode.com/uploads/2018/10/12/keyboard.png)

**Example 1:**

**Input:** words = ["Hello","Alaska","Dad","Peace"]

**Output:** ["Alaska","Dad"]

**Explanation:**

Both `"a"` and `"A"` are in the 2nd row of the American keyboard due to case insensitivity.

**Example 2:**

**Input:** words = ["omk"]

**Output:** []

**Example 3:**

**Input:** words = ["adsdf","sfd"]

**Output:** ["adsdf","sfd"]

**Constraints:**

- `1 <= words.length <= 20`
- `1 <= words[i].length <= 100`
- `words[i]` consists of English letters (both lowercase and uppercase).
___
## Code
```cpp
class Solution {
public:
    vector<string> findWords(vector<string>& words) {
        std::vector<std::string> result;

        std::unordered_set<char> first{'q', 'w', 'e','r','t','y','u','i','o','p'}; 
        std::unordered_set<char> second{'a','s','d','f','g','h','j','k','l'}; 
        std::unordered_set<char> third{'z','x','c','v','b','n','m'}; 

        for (auto& word : words)
        {
            bool has_first{false};
            bool has_second{false};
            bool has_third{false};
            for (auto symbol : word)
                if (first.count(std::tolower(symbol)))
                    has_first = true;
                else if (second.count(std::tolower(symbol)))
                    has_second = true;
                else if (third.count(std::tolower(symbol)))
                    has_third = true;

            if ((has_first && !(has_second || has_third)) ||
                (has_second && !(has_first || has_third)) ||
                (has_third && !(has_first || has_second)))
                result.push_back(word);
        }

        return result;
    }
};
```
___
#cs #leetcode #array #cpp